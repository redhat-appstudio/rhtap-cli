---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: start-pipelines
  annotations:
    tekton.dev/displayName: "Start Pipelines"
    tekton.dev/categories: "Pipeline"
    tekton.dev/tags: "pipeline,start,rhtap"
spec:
  description: >-
    This task starts one or more rhtap-cli-e2e pipelines based on configuration.
    It supports both single configuration mode and periodic configuration mode
    (multiple configs with separators and testplans).
  params:
    - name: snapshot
      description: "The JSON string representing the snapshot of the application under test."
      type: string
    - name: job-spec
      description: "Job specification metadata"
      type: string
    - name: rhads-config
      description: "RHADS configuration data (single config or array of configs with separators)"
      type: string
    - name: mode
      description: "Pipeline mode: 'single' for single config, 'periodic' for multiple configs with separators"
      type: string
      default: "single"
    - name: konflux-test-infra-secret
      description: "The name of secret where testing infrastructures credentials are stored"
      type: string
    - name: cloud-credential-key
      description: "The key secret from konflux-test-infra-secret where all AWS ROSA configurations are stored"
      type: string
    - name: ocp-instance-type
      description: "The type of machine to use for the cluster nodes"
      type: string
      default: "m5.2xlarge"
    - name: ocp-replicas
      description: "The number of replicas for the cluster nodes"
      type: string
      default: "3"
    - name: context-pipeline-run-name
      description: "Context pipeline run name for labeling"
      type: string
  results:
    - name: pipeline-runs
      description: "Array of started pipeline run names"
  steps:
    - name: start-pipelines
      image: quay.io/openshift-pipeline/ci
      env:
        - name: SNAPSHOT
          value: $(params.snapshot)
        - name: JOB_SPEC
          value: $(params.job-spec)
        - name: RHADS_CONFIG
          value: $(params.rhads-config)
        - name: MODE
          value: $(params.mode)

        - name: CONTEXT_PIPELINE_RUN_NAME
          value: $(params.context-pipeline-run-name)
        - name: KONFLUX_TEST_INFRA_SECRET
          value: $(params.konflux-test-infra-secret)
        - name: CLOUD_CREDENTIAL_KEY
          value: $(params.cloud-credential-key)
        - name: OCP_INSTANCE_TYPE
          value: $(params.ocp-instance-type)
        - name: OCP_REPLICAS
          value: $(params.ocp-replicas)
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        echo "Starting pipelines in mode: $MODE"
        # Extract konflux metadata from current pod environment
        # These environment variables are automatically set by Tekton
        KONFLUX_NAMESPACE="${KONFLUX_NAMESPACE:-$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)}"
        # Extract labels from the current pipeline run using oc/kubectl
        CURRENT_PR=$(oc get pipelinerun -n "${KONFLUX_NAMESPACE}" --field-selector metadata.name="${CONTEXT_PIPELINE_RUN_NAME}" -o json 2>/dev/null || echo '{}')
        KONFLUX_APPLICATION_NAME=$(echo "$CURRENT_PR" | jq -r '.items[0].metadata.labels["appstudio.openshift.io/application"] // "rhtap-cli"')
        KONFLUX_COMPONENT_NAME=$(echo "$CURRENT_PR" | jq -r '.items[0].metadata.labels["appstudio.openshift.io/component"] // "rhtap-cli"')
        # Fallback values if extraction fails
        KONFLUX_APPLICATION_NAME="${KONFLUX_APPLICATION_NAME:-rhtap-cli}"
        KONFLUX_COMPONENT_NAME="${KONFLUX_COMPONENT_NAME:-rhtap-cli}"
        echo "Using Konflux metadata: namespace=$KONFLUX_NAMESPACE, app=$KONFLUX_APPLICATION_NAME, component=$KONFLUX_COMPONENT_NAME"
        # Extract images from snapshot
        tssc_image=$(echo "${SNAPSHOT}" | jq -r '.components[] |select(.name=="rhtap-cli").containerImage')
        tssc_test_image=$(echo "${SNAPSHOT}" | jq -r '.components[] |select(.name=="tssc-test").containerImage')

        GIT_REPO="$(jq -r '.git.repo // empty' <<< $JOB_SPEC)"
        KONFLUX_URL="https://konflux-ui.apps.stone-prd-rh01.pg1f.p1.openshiftapps.com"

        if [[ "${GIT_REPO}" = "rhtap-cli" ]]; then
          REPO_ORG=$(jq -r '.git.source_repo_org' <<< $JOB_SPEC)
          BRANCH=$(jq -r '.git.source_repo_branch' <<< $JOB_SPEC)
        else
          REPO_ORG="redhat-appstudio"
          BRANCH="main"
        fi

        PIPELINERUNS_ARRAY=()

        # Function to start a single pipeline
        start_single_pipeline() {
          local ocp_version="$1"
          local config="$2"
          local testplan_b64="$3"
          local config_suffix="$4"
          echo "Starting pipeline for OCP version: $ocp_version"
          local pipeline_run
          
          # Build the tkn command with proper parameter handling
          local tkn_params=(
            "--param" "ocp-version=$ocp_version"
            "--param" "job-spec=$JOB_SPEC"
            "--param" "konflux-test-infra-secret=$KONFLUX_TEST_INFRA_SECRET"
            "--param" "rhads-config=$config"
            "--param" "testplan=${testplan_b64:-}"
            "--param" "cloud-credential-key=$CLOUD_CREDENTIAL_KEY"
            "--param" "machine-type=$OCP_INSTANCE_TYPE"
            "--param" "replicas=$OCP_REPLICAS"
          )
          
          # Add optional image parameters
          if [[ "${tssc_image}" != "" ]]; then
            tkn_params+=("--param" "tssc-image=${tssc_image}")
          fi
          if [[ "${tssc_test_image}" != "" ]]; then
            tkn_params+=("--param" "tssc-test-image=${tssc_test_image}")
          fi
          
          # Add labels and other flags
          tkn_params+=(
            "--use-param-defaults"
            "--labels" "appstudio.openshift.io/component=${KONFLUX_COMPONENT_NAME}"
            "--labels" "appstudio.openshift.io/application=${KONFLUX_APPLICATION_NAME}"
            "--labels" "pipelines.appstudio.openshift.io/type=${CONTEXT_PIPELINE_RUN_NAME}"
            "--labels" "test.appstudio.openshift.io/scenario=pr-e2e-tests"
            "--labels" "custom.appstudio.openshift.io/main-pipeline-run=${CONTEXT_PIPELINE_RUN_NAME}"
            "--prefix-name" "e2e-$ocp_version$config_suffix"
            "-o" "name"
          )
          
          echo "Starting pipeline with testplan (${#testplan_b64} chars): ${testplan_b64:0:50}..."
          pipeline_run=$(tkn pipeline start -f https://raw.githubusercontent.com/jkopriva/rhtap-cli/refs/heads/RHTAP-5290/integration-tests/pipelines/rhtap-cli-e2e.yaml "${tkn_params[@]}")
          #pipeline_run=$(tkn pipeline start -f https://raw.githubusercontent.com/$REPO_ORG/rhtap-cli/refs/heads/$BRANCH/integration-tests/pipelines/rhtap-cli-e2e.yaml "${tkn_params[@]}")
          echo "Started new pipelinerun: ${KONFLUX_URL}/ns/${KONFLUX_NAMESPACE}/applications/${KONFLUX_APPLICATION_NAME}/pipelineruns/${pipeline_run}"
          PIPELINERUNS_ARRAY+=($pipeline_run)
        }

        if [[ "$MODE" == "periodic" ]]; then
          echo "Processing periodic configurations..."
          echo "RHADS Config data:"
          echo "$RHADS_CONFIG"
          # Count configurations for informational purposes
          CONFIG_COUNT=$(echo "$RHADS_CONFIG" | grep -o -e "---CONFIG_SEPARATOR---" | wc -l)
          CONFIG_COUNT=$((CONFIG_COUNT + 1))  # Add 1 because there's one more config than separators
          echo "Found $CONFIG_COUNT configurations to process"
          # Create a pipeline for every RHADS config using pure bash string manipulation
          CONFIG_INDEX=0
          # Split the configurations using bash string manipulation
          REMAINING_CONFIG="$RHADS_CONFIG"
          while [[ -n "$REMAINING_CONFIG" ]]; do
            # Find the next separator
            if [[ "$REMAINING_CONFIG" == *"---CONFIG_SEPARATOR---"* ]]; then
              # Extract config before separator
              FULL_CONFIG="${REMAINING_CONFIG%%---CONFIG_SEPARATOR---*}"
              # Remove processed config and separator from remaining
              REMAINING_CONFIG="${REMAINING_CONFIG#*---CONFIG_SEPARATOR---}"
            else
              # Last config (no separator after it)
              FULL_CONFIG="$REMAINING_CONFIG"
              REMAINING_CONFIG=""
            fi
            # Trim whitespace from config
            FULL_CONFIG=$(echo "$FULL_CONFIG" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            CONFIG_INDEX=$(( $CONFIG_INDEX + 1 ))
            echo "==================== Configuration $CONFIG_INDEX ===================="
            echo "$FULL_CONFIG"
            echo "================================================================"
            # Split RHADS config and testplan
            if [[ "$FULL_CONFIG" == *"---TESTPLAN_START---"* ]]; then
              # Extract RHADS config (before testplan)
              CONFIG="${FULL_CONFIG%%---TESTPLAN_START---*}"
              # Extract testplan (between markers)
              TESTPLAN_PART="${FULL_CONFIG#*---TESTPLAN_START---}"
              TESTPLAN="${TESTPLAN_PART%%---TESTPLAN_END---*}"
              # Trim whitespace from both parts
              CONFIG=$(echo "$CONFIG" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              TESTPLAN=$(echo "$TESTPLAN" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              echo "RHADS Config:"
              echo "$CONFIG"
              echo "Testplan:"
              echo "$TESTPLAN"
              # Encode testplan to base64
              TESTPLAN_B64=$(echo "$TESTPLAN" | base64 -w 0)
              echo "Testplan base64: $TESTPLAN_B64"
            else
              # No testplan found, use config as-is
              CONFIG="$FULL_CONFIG"
              TESTPLAN_B64=""
              echo "No testplan found for this configuration"
            fi
            # Extract OCP version from this configuration
            if [[ $CONFIG =~ OCP=\"([^\"]+)\" ]]; then
              OCP_VERSION="${BASH_REMATCH[1]}"
              echo "Successfully extracted OCP version: $OCP_VERSION from configuration $CONFIG_INDEX"
              # Start pipeline using shared function
              start_single_pipeline "$OCP_VERSION" "$CONFIG" "$TESTPLAN_B64" "-config$CONFIG_INDEX"
            else
              echo "Warning: Could not extract OCP version from configuration $CONFIG_INDEX"
            fi
          done
          echo "Started $CONFIG_INDEX sub-pipelines for periodic testing"
        else
          echo "Processing single configuration..."
          RHADS_CONFIG_CONTENT=$(echo "$RHADS_CONFIG")
          echo "Configuration:"
          echo "$RHADS_CONFIG_CONTENT"
          # Extract OCP versions from RHADS config
          [[ $RHADS_CONFIG_CONTENT =~ OCP=\"([^\"]+)\" ]] && IFS=',' read -ra OCP_VERSIONS <<< "${BASH_REMATCH[1]}"
          echo "Running tests for OCP versions: ${OCP_VERSIONS[*]}"
          # Loop through each OCP version and start a sub-pipeline for each
          for OCP_VERSION in "${OCP_VERSIONS[@]}"; do
            echo "Starting sub-pipeline for OCP version: $OCP_VERSION"
            # Start pipeline using shared function
            start_single_pipeline "$OCP_VERSION" "$RHADS_CONFIG_CONTENT" "" ""
          done
        fi

        echo "Total pipelines started: ${#PIPELINERUNS_ARRAY[@]}"

        # Store results
        printf '%s\n' "${PIPELINERUNS_ARRAY[@]}" | jq -R . | jq -s . > $(results.pipeline-runs.path)

        # Wait for completion function
        waitFor() {
          local CONDITION="$1"
          local MESSAGE_RUNNING="$2"
          local MESSAGE_DONE="$3"
          export CONDITION MESSAGE_RUNNING MESSAGE_DONE
          timeout --foreground 120m /bin/bash -c '
            #deserialize plrs array
            set -x
            read -r -a PIPELINERUNS_ARRAY <<< "$PIPELINERUNS_ARRAY_SERIALIZED"
            echo "${PIPELINERUNS_ARRAY[*]}"
            while [[ ${#PIPELINERUNS_ARRAY[@]} -gt 0 ]]; do
              # Create a new array to store pipelines that are still running
              STILL_RUNNING=()
              for PIPELINE_RUN in "${PIPELINERUNS_ARRAY[@]}"; do
                if eval "$CONDITION"; then
                  # Pipeline is still running, keep it in the array
                  STILL_RUNNING+=("$PIPELINE_RUN")
                else
                  # Pipeline is finished, remove it from the array
                  echo "Pipeline $PIPELINE_RUN has finished"
                fi
              done
              # Update the array with only running pipelines
              PIPELINERUNS_ARRAY=("${STILL_RUNNING[@]}")
              if [[ ${#PIPELINERUNS_ARRAY[@]} -gt 0 ]]; then
                echo "$MESSAGE_RUNNING (${#PIPELINERUNS_ARRAY[@]} pipelines remaining)"
                sleep 60
              else
                echo "$MESSAGE_DONE"
                break
              fi
            done
          '
        }

        #Serialize plrs array to be able to export it as var
        export PIPELINERUNS_ARRAY_SERIALIZED="${PIPELINERUNS_ARRAY[*]}"

        waitFor '! oc get pipelinerun/$PIPELINE_RUN -n ${KONFLUX_NAMESPACE} &>/dev/null' "Pipelines are still starting. Waiting 1 minute" "All pipelines have started"
        waitFor '[[ $(oc get pipelinerun/$PIPELINE_RUN -n ${KONFLUX_NAMESPACE} -o jsonpath="{.status.conditions[?(@.type==\"Succeeded\")].status}") == "" ]]' "Waiting for nested pipelinerun status to be set. Waiting 1 minute" "Nested pipelinerun status is set"
        waitFor '[[ $(oc get pipelinerun/$PIPELINE_RUN -n ${KONFLUX_NAMESPACE} -o jsonpath="{.status.conditions[?(@.type==\"Succeeded\")].status}") == "Unknown" ]]' "Nested pipelines are still running. Waiting 1 minute" "All nested pipelines finished"

        # Explore and report status of all failed pipelineruns. Fail if anything failed
        SOME_PIPELINE_FAILED=false
        SOME_PIPELINE_SUCCEEDED=false
        for PIPELINE_RUN in "${PIPELINERUNS_ARRAY[@]}"; do
          if [[ $(oc get pipelinerun/$PIPELINE_RUN -n ${KONFLUX_NAMESPACE} -o jsonpath="{.status.conditions[?(@.type==\"Succeeded\")].status}") == "False" ]]; then
            if ! $SOME_PIPELINE_FAILED ; then
              echo "List of failed PLRs:"
            fi
            echo "${KONFLUX_URL}/ns/${KONFLUX_NAMESPACE}/applications/${KONFLUX_APPLICATION_NAME}/pipelineruns/${PIPELINE_RUN}"
            SOME_PIPELINE_FAILED=true
          elif [[ $(oc get pipelinerun/$PIPELINE_RUN -n ${KONFLUX_NAMESPACE} -o jsonpath="{.status.conditions[?(@.type==\"Succeeded\")].status}") == "True" ]]; then
            SOME_PIPELINE_SUCCEEDED=true
          fi
        done
        if $SOME_PIPELINE_SUCCEEDED ; then
          exit 0
        fi
        if $SOME_PIPELINE_FAILED ; then
          exit 1
        fi
        echo "Pipeline processing completed successfully"
